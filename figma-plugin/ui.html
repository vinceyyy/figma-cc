<!DOCTYPE html>
<html lang="en">
<head>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 12px;
    color: #333;
    padding: 12px;
    padding-bottom: 44px;
    background: #fff;
  }
  h2 { font-size: 14px; font-weight: 600; margin-bottom: 12px; }
  .section { margin-bottom: 12px; }
  .label { font-size: 11px; font-weight: 500; color: #666; margin-bottom: 4px; }
  .selection-info {
    background: #f5f5f5;
    border-radius: 6px;
    padding: 8px 10px;
    font-size: 11px;
    color: #555;
  }
  .context-input {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 12px;
    font-family: inherit;
    resize: vertical;
    min-height: 48px;
  }
  .context-input:focus { outline: none; border-color: #18a0fb; }
  .persona-list { list-style: none; }
  .persona-list li {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 0;
  }
  .persona-list input[type="checkbox"] { accent-color: #18a0fb; }
  .btn {
    display: block;
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    background: #18a0fb;
    color: #fff;
    transition: background 0.15s;
  }
  .btn:hover { background: #0d8de5; }
  .btn:disabled { background: #ccc; cursor: not-allowed; }
  .btn-secondary {
    background: transparent;
    color: #18a0fb;
    border: 1px solid #18a0fb;
    margin-top: 8px;
  }
  .btn-secondary:hover { background: #f0f8ff; }
  .empty-state {
    text-align: center;
    padding: 40px 20px;
    color: #999;
  }
  .empty-state p { font-size: 13px; }
  .loading {
    text-align: center;
    padding: 40px 20px;
  }
  .spinner {
    width: 32px; height: 32px;
    border: 3px solid #eee;
    border-top-color: #18a0fb;
    border-radius: 50%;
    animation: spin 0.8s ease-in-out infinite;
    margin: 0 auto 12px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .feedback-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 8px;
    margin-bottom: 10px;
  }
  .score {
    background: #18a0fb;
    color: #fff;
    border-radius: 4px;
    padding: 2px 8px;
    font-size: 12px;
    font-weight: 600;
  }
  .impression { font-size: 12px; color: #555; margin-bottom: 8px; font-style: italic; }
  .issue {
    background: #fff;
    border-radius: 4px;
    padding: 6px 8px;
    margin-bottom: 4px;
    font-size: 11px;
    cursor: pointer;
  }
  .issue:hover { background: #f0f4ff; }
  .issue-severity {
    display: inline-block;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    padding: 2px 6px;
    border-radius: 3px;
    margin-right: 4px;
    letter-spacing: 0.03em;
  }
  .severity-high { background: #fde8e8; color: #c53030; }
  .severity-medium { background: #fef3cd; color: #856404; }
  .severity-low { background: #d4edda; color: #155724; }
  .positives-section {
    margin-top: 10px;
  }
  .positives-heading {
    font-size: 11px;
    font-weight: 600;
    color: #2f855a;
    margin-bottom: 4px;
  }
  .positive { color: #2f855a; font-size: 11px; padding: 2px 0; display: flex; gap: 6px; }
  .positive::before { content: "\2713"; flex-shrink: 0; }
  .error-state {
    text-align: center;
    padding: 20px;
    color: #c53030;
  }
  .error-hint {
    color: #999;
    font-size: 11px;
    margin-top: 8px;
    margin-bottom: 16px;
  }
  .error-msg { background: #fde8e8; border-radius: 6px; padding: 10px; margin-bottom: 10px; font-size: 12px; }
  .warning-msg {
    background: #fffbeb;
    border: 1px solid #f6e05e;
    border-radius: 6px;
    padding: 10px 12px;
    margin-bottom: 10px;
    font-size: 12px;
    color: #975a16;
  }
  .api-url-input {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 11px;
    font-family: monospace;
    margin-bottom: 12px;
  }
  .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }
  .size-btns {
    display: flex;
    gap: 4px;
  }
  .size-btn {
    padding: 2px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: #fff;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    color: #666;
  }
  .size-btn.active {
    background: #18a0fb;
    color: #fff;
    border-color: #18a0fb;
  }
  .annotation-container {
    margin-bottom: 8px;
    border-radius: 6px;
    overflow: visible;
    background: #f0f0f0;
  }
  .annotation-image-wrapper {
    position: relative;
  }
  .annotation-container img {
    display: block;
    width: 100%;
    height: auto;
    border-radius: 0 0 6px 6px;
  }
  .annotation-box {
    position: absolute;
    border: 2px dashed;
    border-radius: 3px;
    opacity: 0.6;
    transition: opacity 0.15s;
    cursor: pointer;
  }
  .annotation-box:hover, .annotation-box.highlight {
    opacity: 1;
  }
  .annotation-box .ann-label {
    position: absolute;
    top: -1px;
    left: -1px;
    font-size: 9px;
    font-weight: 700;
    padding: 1px 4px;
    border-radius: 0 0 3px 0;
    color: #fff;
    line-height: 1.2;
    z-index: 2;
  }
  .ann-tooltip-fixed {
    display: none;
    position: fixed;
    background: #1a1a2e;
    color: #f0f0f0;
    font-size: 12px;
    font-weight: 400;
    padding: 10px 14px;
    border-radius: 8px;
    width: max-content;
    max-width: 380px;
    line-height: 1.5;
    z-index: 9999;
    pointer-events: none;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35), 0 2px 8px rgba(0,0,0,0.2);
    letter-spacing: 0.01em;
  }
  .ann-tooltip-fixed.visible {
    display: block;
    animation: tooltipIn 0.12s ease-out;
  }
  @keyframes tooltipIn {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .annotation-box.severity-high { border-color: #c53030; background: rgba(197,48,48,0.08); }
  .annotation-box.severity-high .ann-label { background: #c53030; }
  .annotation-box.severity-medium { border-color: #b7791f; background: rgba(183,121,31,0.08); }
  .annotation-box.severity-medium .ann-label { background: #b7791f; }
  .annotation-box.severity-low { border-color: #276749; background: rgba(39,103,73,0.08); }
  .annotation-box.severity-low .ann-label { background: #276749; }
  .issue.highlight { outline: 2px solid #18a0fb; outline-offset: 1px; border-radius: 4px; }
  .flow-strip {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    overflow-y: visible;
    margin-bottom: 8px;
    padding-bottom: 4px;
  }
  .flow-strip .annotation-container {
    flex: 0 0 auto;
    width: 280px;
    margin-bottom: 0;
  }
  .frame-label {
    display: block;
    font-size: 10px;
    font-weight: 600;
    color: #555;
    background: #eef1f5;
    padding: 3px 8px;
    border-radius: 4px 4px 0 0;
    border-bottom: 1px solid #dde0e4;
  }
  .layout-btn {
    padding: 2px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: #fff;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    color: #666;
    margin-left: 8px;
  }
  .layout-btn.active {
    background: #18a0fb;
    color: #fff;
    border-color: #18a0fb;
  }

  /* Two-column results layout */
  .results-2col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    align-items: start;
  }
  .results-2col .images-column {
    position: sticky;
    top: 0;
    max-height: 100vh;
    overflow-y: auto;
  }
  .results-2col .feedback-column {
    overflow-y: auto;
  }

  /* In 2-col mode, flow strip goes vertical instead of horizontal */
  .results-2col .flow-strip {
    flex-direction: column;
    overflow-x: visible;
    overflow-y: auto;
    padding-top: 0;
  }
  .results-2col .flow-strip .annotation-container {
    width: 100%;
  }
  .annotation-box.flash {
    animation: flashHighlight 1.5s ease-out;
  }
  @keyframes flashHighlight {
    0% { outline: 3px solid #18a0fb; outline-offset: 2px; }
    100% { outline: 3px solid transparent; outline-offset: 2px; }
  }

  /* Persona tabs */
  .persona-tabs {
    display: flex;
    gap: 0;
    border-bottom: 2px solid #e2e8f0;
    margin-bottom: 6px;
    overflow-x: auto;
  }
  .persona-tab {
    padding: 8px 14px;
    font-size: 11px;
    font-weight: 600;
    color: #666;
    cursor: pointer;
    border: none;
    background: none;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
    white-space: nowrap;
    transition: color 0.15s, border-color 0.15s;
  }
  .persona-tab:hover {
    color: #333;
    background: #f8f9fa;
    border-radius: 4px 4px 0 0;
  }
  .persona-tab.active {
    color: #fff;
    background: #18a0fb;
    border-bottom-color: #18a0fb;
    border-radius: 4px 4px 0 0;
  }
  .persona-tab .tab-score {
    display: inline-block;
    background: #e2e8f0;
    color: #555;
    font-size: 10px;
    padding: 1px 5px;
    border-radius: 3px;
    margin-left: 4px;
  }
  .persona-tab.active .tab-score {
    background: #18a0fb;
    color: #fff;
  }
  .tab-panel {
    display: none;
  }
  .tab-panel.active {
    display: block;
  }

  /* Subtle text link button */
  .link-btn {
    background: none;
    border: none;
    color: #999;
    font-size: 11px;
    text-decoration: underline;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: center;
    transition: color 0.15s ease;
  }
  .link-btn:hover { color: #666; }

  /* Ghost-style cancel button */
  .btn-cancel {
    display: inline-block;
    padding: 6px 16px;
    border: 1px solid #ccc;
    border-radius: 6px;
    background: #fff;
    color: #666;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
  }
  .btn-cancel:hover { background: #c53030; color: #fff; border-color: #c53030; }

  /* Progress indicator */
  .progress-container {
    padding: 16px;
  }
  .progress-phase {
    font-size: 11px;
    color: #999;
    margin-bottom: 12px;
    text-align: center;
  }
  .progress-bar-track {
    width: 100%;
    height: 4px;
    background: #e2e8f0;
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 16px;
  }
  .progress-hint {
    font-size: 10px;
    color: #bbb;
    text-align: center;
    margin-bottom: 12px;
  }
  .progress-bar-fill {
    height: 100%;
    width: 30%;
    background: #18a0fb;
    border-radius: 2px;
    animation: indeterminate 1.4s ease-in-out infinite;
  }
  @keyframes indeterminate {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(430%); }
  }
  .progress-cancel {
    text-align: center;
    margin-top: 8px;
  }
  .brand-footer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: #053057;
    padding: 6px 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    z-index: 100;
  }
  .brand-footer span {
    color: #FFFFFF;
    font-size: 10px;
    opacity: 0.8;
  }
  .brand-footer svg {
    height: 14px;
    width: auto;
  }
</style>
</head>
<body>
  <div class="header-row">
    <h2 style="margin-bottom:0">Design Feedback</h2>
    <div class="size-btns">
      <button type="button" class="size-btn active" data-w="560" data-h="600">M</button>
      <button type="button" class="size-btn" data-w="560" data-h="800">L</button>
      <button type="button" class="size-btn" data-w="700" data-h="1000">XL</button>
      <button type="button" class="size-btn" data-w="1200" data-h="1000">XXL</button>
      <button type="button" class="layout-btn" id="layoutToggle" title="Toggle 2-column layout">2-col</button>
    </div>
  </div>

  <!-- Connect state (initial) -->
  <div id="state-connect">
    <div style="text-align:center; padding: 40px 20px;">
      <h2 style="margin-bottom:16px;">Connect to Backend</h2>
      <p style="color:#666; font-size:12px; margin-bottom:16px;">Enter your backend URL to get started</p>
      <input type="text" class="api-url-input" id="apiUrl"
             placeholder="https://design-feedback.demo.blend360.app"
             style="margin-bottom:12px;">
      <div id="apiKeyRow" style="display:none;">
        <input type="password" class="api-url-input" id="apiKey"
               placeholder="API Key"
               autocomplete="off"
               style="margin-bottom:12px;">
      </div>
      <button type="button" class="btn" id="btnConnect">Connect</button>
      <div id="connectError" style="display:none; margin-top:12px;" class="error-msg"></div>
      <div id="connectLoading" style="display:none; margin-top:12px;">
        <div class="spinner" style="margin:0 auto;"></div>
        <p style="color:#999; font-size:11px; margin-top:8px;">Connecting...</p>
      </div>
    </div>
  </div>

  <!-- Empty state (connected but no selection) -->
  <div id="state-empty" style="display:none;" class="empty-state">
    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" role="img">
      <title>Frame icon</title>
      <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
      <line x1="3" y1="9" x2="21" y2="9"/>
      <line x1="9" y1="21" x2="9" y2="9"/>
    </svg>
    <p style="margin-top:12px; font-size:13px; font-weight:500; color:#333;">No frames selected</p>
    <p style="font-size:11px; color:#999; margin-top:4px;">Select one or more frames in Figma to analyze</p>
    <button type="button" class="link-btn" id="btnChangeBackendEmpty" style="margin-top:16px;">Change Backend</button>
  </div>

  <!-- Ready state -->
  <div id="state-ready" style="display:none;">
    <div class="section">
      <div class="label">Selected Frame</div>
      <div class="selection-info" id="selectionInfo"></div>
    </div>
    <div class="section">
      <div class="label">Context (optional)</div>
      <textarea class="context-input" id="contextInput"
                placeholder="e.g., Checkout page for an e-commerce app targeting young adults"></textarea>
    </div>
    <div class="section">
      <div class="label">Get feedback from:</div>
      <ul class="persona-list" id="personaList">
        <!-- Dynamically populated from backend -->
      </ul>
    </div>
    <button type="button" class="btn" id="btnGetFeedback">Get Feedback</button>
    <button type="button" class="link-btn" id="btnChangeBackend">Change Backend</button>
  </div>

  <!-- Results state -->
  <div id="state-results" style="display:none;">
    <div id="feedbackCards"></div>
    <button type="button" class="btn-secondary btn" id="btnNewFeedback">New Analysis</button>
  </div>

  <!-- Error state -->
  <div id="state-error" style="display:none;">
    <div class="error-state">
      <div class="error-msg" id="errorMsg"></div>
      <p class="error-hint">Check that your backend server is running and the URL is correct.</p>
      <button type="button" class="btn" id="btnRetry">Retry</button>
    </div>
  </div>

<div class="ann-tooltip-fixed" id="annTooltip"></div>

<script>
  // State management
  let currentMetadata = null;
  let currentImage = null;   // single frame base64
  let currentFrames = null;  // multi-frame array [{image, metadata}, ...]
  let twoColMode = false;
  let allFeedbackStore = [];
  let streamingAbort = null;
  let backendUrl = '';
  let apiKey = '';
  let availablePersonas = [];
  let savedUrl = '';
  let savedApiKey = '';
  let autoConnectAttempted = false;

  // Auto-connect once both saved URL and API key have been loaded from clientStorage.
  // If the server doesn't need auth, the saved key will be ignored.
  function tryAutoConnect() {
    if (autoConnectAttempted || !savedUrl) return;
    autoConnectAttempted = true;
    // If we have a saved key, try direct connect (skip /health check).
    // Otherwise, use checkAuthRequired which will ask for a key if needed.
    if (savedApiKey) {
      connectToBackend(savedUrl, savedApiKey);
    } else {
      checkAuthRequired(savedUrl);
    }
  }

  // Check if the backend requires an API key by calling /health
  async function checkAuthRequired(url) {
    const cleanUrl = url.replace(/\/+$/, '');
    const connectError = document.getElementById('connectError');
    const connectLoading = document.getElementById('connectLoading');
    const apiKeyRow = document.getElementById('apiKeyRow');
    connectError.style.display = 'none';
    connectLoading.style.display = 'block';
    document.getElementById('btnConnect').disabled = true;

    try {
      const resp = await fetch(`${cleanUrl}/health`, {
        headers: { 'ngrok-skip-browser-warning': 'true' },
      });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const data = await resp.json();

      if (data.auth_required) {
        // Show API key input and wait for user to fill it
        apiKeyRow.style.display = 'block';
        connectLoading.style.display = 'none';
        document.getElementById('btnConnect').disabled = false;
        // Change button to proceed with key
        document.getElementById('btnConnect').textContent = 'Connect with API Key';
        document.getElementById('btnConnect').onclick = () => {
          const key = document.getElementById('apiKey').value.trim();
          if (!key) {
            connectError.textContent = 'API key is required for this server.';
            connectError.style.display = 'block';
            return;
          }
          connectToBackend(cleanUrl, key);
        };
      } else {
        // No auth needed — connect directly without showing key input
        apiKeyRow.style.display = 'none';
        await connectToBackend(cleanUrl, '');
      }
    } catch (e) {
      connectError.textContent = `Can't reach backend: ${e.message}`;
      connectError.style.display = 'block';
      connectLoading.style.display = 'none';
      document.getElementById('btnConnect').disabled = false;
    }
  }

  async function connectToBackend(url, key) {
    const cleanUrl = url.replace(/\/+$/, '');
    apiKey = key || '';
    const connectError = document.getElementById('connectError');
    const connectLoading = document.getElementById('connectLoading');
    connectError.style.display = 'none';
    connectLoading.style.display = 'block';
    document.getElementById('btnConnect').disabled = true;

    try {
      const resp = await fetch(`${cleanUrl}/api/personas`, {
        headers: {
          'ngrok-skip-browser-warning': 'true',
          ...(apiKey ? { 'X-API-Key': apiKey } : {}),
        },
      });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      availablePersonas = await resp.json();

      if (!availablePersonas.length) throw new Error('No personas available on this server');

      backendUrl = cleanUrl;
      // Save URL and API key for next session
      parent.postMessage({ pluginMessage: { type: 'save-backend-url', url: cleanUrl } }, '*');
      parent.postMessage({ pluginMessage: { type: 'save-api-key', key: apiKey } }, '*');

      // Populate persona checkboxes
      const list = document.getElementById('personaList');
      list.innerHTML = '';
      availablePersonas.forEach((p, i) => {
        const li = document.createElement('li');
        const checked = i < 2 ? 'checked' : '';
        li.innerHTML = `<label><input type="checkbox" value="${esc(p.id)}" ${checked}> ${esc(p.label)}</label>`;
        list.appendChild(li);
      });

      // Transition based on current selection state
      if (currentMetadata) {
        showState('state-ready');
      } else {
        showState('state-empty');
      }
    } catch (e) {
      connectError.textContent = `Can't reach backend: ${e.message}`;
      connectError.style.display = 'block';
    } finally {
      connectLoading.style.display = 'none';
      document.getElementById('btnConnect').disabled = false;
      // Reset button for next connection attempt
      document.getElementById('btnConnect').textContent = 'Connect';
      document.getElementById('btnConnect').onclick = null;
    }
  }

  function showState(stateId) {
    ['state-connect', 'state-empty', 'state-ready', 'state-results', 'state-error']
      .forEach(id => { document.getElementById(id).style.display = 'none'; });
    document.getElementById(stateId).style.display = 'block';
  }

  // Handle messages from plugin main thread
  onmessage = (event) => {
    const msg = event.data.pluginMessage;
    if (!msg) return;

    switch (msg.type) {
      case 'saved-backend-url':
        document.getElementById('apiUrl').value = msg.url;
        savedUrl = msg.url;
        tryAutoConnect();
        break;
      case 'saved-api-key':
        document.getElementById('apiKey').value = msg.key;
        savedApiKey = msg.key;
        tryAutoConnect();
        break;
      case 'selection-cleared':
        currentMetadata = null;
        currentImage = null;
        currentFrames = null;
        if (backendUrl) showState('state-empty');
        break;
      case 'selection-info': {
        currentMetadata = msg.metadata;
        const info = document.getElementById('selectionInfo');
        info.textContent = `"${msg.metadata.frameName}" (${msg.metadata.dimensions.width} x ${msg.metadata.dimensions.height})`;
        if (backendUrl) showState('state-ready');
        break;
      }
      case 'multi-selection-info': {
        currentMetadata = msg.frames; // array of {frameName, dimensions}
        currentFrames = null;
        currentImage = null;
        const info = document.getElementById('selectionInfo');
        const names = msg.frames.map(f => `"${f.frameName}"`).join(' \u2192 ');
        info.textContent = `Flow: ${names} (${msg.frames.length} frames)`;
        if (backendUrl) showState('state-ready');
        break;
      }
      case 'export-result':
        currentImage = msg.image;
        currentFrames = null;
        sendFeedbackRequest();
        break;
      case 'export-result-multi':
        currentFrames = msg.frames;
        currentImage = null;
        sendFeedbackRequest();
        break;
      case 'export-progress': {
        const name = msg.frameName ? ` \u2014 "${msg.frameName}"` : '';
        setProgressPhase(`Exporting frame ${msg.current} of ${msg.total}${name}...`);
        break;
      }
      case 'export-error':
        showState('state-error');
        document.getElementById('errorMsg').textContent = `Export failed: ${msg.error}`;
        break;
    }
  };

  // Get selected personas
  function getSelectedPersonas() {
    return Array.from(document.querySelectorAll('#personaList input:checked'))
      .map(cb => cb.value);
  }

  // Get Feedback button
  document.getElementById('btnGetFeedback').onclick = () => {
    const personas = getSelectedPersonas();
    if (personas.length === 0) {
      alert('Select at least one persona');
      return;
    }
    // Build progress UI immediately
    buildProgressUI();
    showState('state-results');
    // Hide the "New Analysis" button during progress (cancel is inside progress container)
    document.getElementById('btnNewFeedback').style.display = 'none';
    // Request image export from main thread
    parent.postMessage({ pluginMessage: { type: 'export-selection' } }, '*');
  };

  // Build the progress indicator UI
  function buildProgressUI() {
    const container = document.getElementById('feedbackCards');
    container.innerHTML = '';

    const html = `
      <div class="progress-container" id="progressContainer">
        <div class="progress-phase" id="progressPhase">Preparing...</div>
        <div class="progress-bar-track">
          <div class="progress-bar-fill"></div>
        </div>
        <div class="progress-hint">This may take 1\u20133 minutes</div>
        <div class="progress-cancel">
          <button type="button" class="btn-cancel" id="btnCancelStream">Cancel</button>
        </div>
      </div>
    `;
    container.innerHTML = html;

    // Wire cancel button
    document.getElementById('btnCancelStream').onclick = () => {
      if (streamingAbort) {
        streamingAbort.abort();
      }
      showState('state-ready');
    };
  }


  // Send feedback request to API (SSE streaming)
  async function sendFeedbackRequest() {
    allFeedbackStore = [];
    const apiUrl = backendUrl;
    const personas = getSelectedPersonas();
    const context = document.getElementById('contextInput').value.trim() || null;

    const reqBody = currentFrames
      ? {
          frames: currentFrames.map(f => ({
            image: f.image,
            metadata: {
              frame_name: f.metadata.frameName,
              dimensions: f.metadata.dimensions,
              text_content: f.metadata.textContent || [],
              colors: f.metadata.colors || [],
              component_names: f.metadata.componentNames || [],
            },
          })),
          personas: personas,
          context: context,
        }
      : {
          image: currentImage,
          metadata: {
            frame_name: currentMetadata.frameName,
            dimensions: currentMetadata.dimensions,
            text_content: currentMetadata.textContent || [],
            colors: currentMetadata.colors || [],
            component_names: currentMetadata.componentNames || [],
          },
          personas: personas,
          context: context,
        };

    try {
      // Update progress phase
      setProgressPhase('Sending to server...');

      streamingAbort = new AbortController();
      const resp = await fetch(`${apiUrl}/api/feedback/stream`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true',
          ...(apiKey ? { 'X-API-Key': apiKey } : {}),
        },
        body: JSON.stringify(reqBody),
        signal: streamingAbort.signal,
      });

      if (!resp.ok) {
        const err = await resp.json().catch(() => ({ detail: resp.statusText }));
        throw new Error(err.detail || `HTTP ${resp.status}`);
      }

      // Response started — backend is processing
      setProgressPhase('Request received...');

      // Pre-create results area (hidden until first result arrives)
      const container = document.getElementById('feedbackCards');
      const tabBar = document.createElement('div');
      tabBar.className = 'persona-tabs';
      tabBar.id = 'personaTabs';
      tabBar.style.display = 'none';
      container.appendChild(tabBar);

      const loadingTab = document.createElement('span');
      loadingTab.id = 'loadingTabIndicator';
      loadingTab.style.cssText = 'display:none;padding:6px 14px;font-size:11px;color:#999;white-space:nowrap;';
      loadingTab.innerHTML = '<span class="spinner" style="width:14px;height:14px;border-width:2px;display:inline-block;vertical-align:middle;margin:0 6px 0 0;"></span> Loading...';
      tabBar.appendChild(loadingTab);

      const panelsContainer = document.createElement('div');
      panelsContainer.id = 'personaPanels';
      container.appendChild(panelsContainer);

      const allFeedback = [];
      let failedCount = 0;
      const reader = resp.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';
      let currentEventType = null;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop(); // keep incomplete line in buffer

        for (const line of lines) {
          if (line.startsWith('event: ')) {
            currentEventType = line.slice(7).trim();
            continue;
          }
          if (line.startsWith('data: ')) {
            const jsonStr = line.slice(6);
            if (jsonStr === '{}') { currentEventType = null; continue; }

            if (currentEventType === 'persona-start') {
              try {
                JSON.parse(jsonStr); // validate
                setProgressPhase('Analyzing your design...');
              } catch (e) { console.warn('Failed to parse persona-start event:', e); }
              currentEventType = null;
              continue;
            }

            if (currentEventType === 'persona-error') {
              try {
                const errData = JSON.parse(jsonStr);
                failedCount++;

                // Add error tab
                const panelId = `panel-err-${failedCount}`;
                const tab = document.createElement('button');
                tab.className = 'persona-tab';
                tab.dataset.panelId = panelId;
                tab.innerHTML = `<span style="color:#c53030">${esc(errData.persona)}</span> <span class="tab-score" style="background:#fde8e8;color:#c53030">Error</span>`;
                tab.onclick = () => switchTab(tab);
                tabBar.insertBefore(tab, loadingTab);

                const panel = document.createElement('div');
                panel.className = 'tab-panel';
                panel.id = panelId;
                panel.innerHTML = `<div class="error-msg">${esc(errData.persona)} failed: ${esc(errData.detail)}</div>`;
                panelsContainer.appendChild(panel);
              } catch (e) { console.warn('Failed to parse persona-error event:', e); }

              // Update remaining indicator
              const remaining = personas.length - allFeedback.length - failedCount;
              if (remaining > 0) {
                loadingTab.innerHTML = `<span class="spinner" style="width:14px;height:14px;border-width:2px;display:inline-block;vertical-align:middle;margin:0 6px 0 0;"></span> ${remaining} more...`;
              } else {
                loadingTab.style.display = 'none';
              }
              currentEventType = null;
              continue;
            }

            // Regular data event (successful persona feedback)
            try {
              const fb = JSON.parse(jsonStr);
              allFeedback.push(fb);
              allFeedbackStore.push(fb);

              // On first successful result: remove loading screen, show results
              if (allFeedback.length === 1) {
                const progressContainer = document.getElementById('progressContainer');
                if (progressContainer) progressContainer.remove();
                tabBar.style.display = 'flex';
              }

              // Update remaining count
              const remaining = personas.length - allFeedback.length - failedCount;
              if (remaining > 0) {
                loadingTab.style.display = 'inline-flex';
                loadingTab.innerHTML = `<span class="spinner" style="width:14px;height:14px;border-width:2px;display:inline-block;vertical-align:middle;margin:0 6px 0 0;"></span> ${remaining} more...`;
              } else {
                loadingTab.style.display = 'none';
              }

              // Create tab + panel
              const panelId = `panel-${allFeedback.length - 1}`;
              const tab = document.createElement('button');
              tab.className = `persona-tab${allFeedback.length === 1 ? ' active' : ''}`;
              tab.dataset.panelId = panelId;
              tab.innerHTML = `${esc(fb.persona_label)} <span class="tab-score">${fb.score}/10</span>`;
              tab.onclick = () => switchTab(tab);
              tabBar.insertBefore(tab, loadingTab);

              const panel = document.createElement('div');
              panel.className = `tab-panel${allFeedback.length === 1 ? ' active' : ''}`;
              panel.id = panelId;
              renderSingleFeedbackCard(panel, fb);
              panelsContainer.appendChild(panel);
            } catch (e) { console.warn('Failed to parse feedback event:', e); }
            currentEventType = null;
          }
          if (line.startsWith('event: done')) {
            loadingTab.style.display = 'none';
          }
        }
      }

      // Streaming complete
      streamingAbort = null;
      const progressContainer = document.getElementById('progressContainer');
      if (progressContainer) progressContainer.remove();
      loadingTab.style.display = 'none';

      if (allFeedback.length === 0) {
        showState('state-results');
        const feedbackCards = document.getElementById('feedbackCards');
        if (failedCount > 0) {
          feedbackCards.innerHTML = '<div class="warning-msg">All personas failed to return feedback. Please try again.</div>';
        } else {
          feedbackCards.innerHTML = '<div class="warning-msg">No feedback received from any persona. The analysis may have timed out — try selecting fewer personas or smaller frames.</div>';
        }
      }

      // Show the "New Analysis" button
      const actionBtn = document.getElementById('btnNewFeedback');
      actionBtn.textContent = 'New Analysis';
      actionBtn.className = 'btn-secondary btn';
      actionBtn.style.cssText = '';
      actionBtn.style.display = '';

    } catch (error) {
      streamingAbort = null;
      const actionBtn = document.getElementById('btnNewFeedback');
      actionBtn.textContent = 'New Analysis';
      actionBtn.className = 'btn-secondary btn';
      actionBtn.style.cssText = '';
      actionBtn.style.display = '';
      if (error.name === 'AbortError') {
        // User cancelled, go back to ready state
        showState('state-ready');
        return;
      }
      showState('state-error');
      document.getElementById('errorMsg').textContent = error.message;
    }
  }

  // Helper: update progress phase text with spinner
  function setProgressPhase(text) {
    const phaseEl = document.getElementById('progressPhase');
    if (phaseEl) {
      phaseEl.textContent = text;
    }
  }

  // Sanitize strings before inserting into HTML to prevent XSS
  function esc(str) {
    const div = document.createElement('div');
    div.textContent = String(str);
    return div.innerHTML;
  }

  // --- Shared HTML helpers ---

  function getCurrentImages() {
    return currentFrames
      ? currentFrames.map(f => f.image)
      : currentImage ? [currentImage] : [];
  }

  function getCurrentFrameNames() {
    return currentFrames
      ? currentFrames.map(f => f.metadata.frameName)
      : currentMetadata?.frameName ? [currentMetadata.frameName] : [];
  }

  function buildFrameHtml(images, frameNames, annotations, issues) {
    const framesHtml = images.map((img, frameIdx) => {
      let boxesHtml = '';
      if (annotations && annotations.length > 0) {
        const frameAnns = annotations.filter(a => (a.frame_index || 0) === frameIdx);
        const sorted = frameAnns.map((ann, i) => ({ ann, i }));
        sorted.sort((a, b) => (b.ann.width_pct * b.ann.height_pct) - (a.ann.width_pct * a.ann.height_pct));

        boxesHtml = sorted.map((entry, renderIdx) => {
          const { ann } = entry;
          const issue = issues ? issues[ann.issue_index] : null;
          const severity = issue ? issue.severity : 'medium';
          const area = issue ? esc(issue.area) : esc(ann.label);
          const desc = issue ? esc(issue.description) : '';
          const num = ann.issue_index + 1;
          const zIndex = renderIdx + 1;
          const sug = issue ? esc(issue.suggestion) : '';
          return `<div class="annotation-box severity-${esc(severity)}"
                       data-issue-index="${ann.issue_index}"
                       data-tip-num="${num}" data-tip-sev="${esc(severity)}" data-tip-area="${area}" data-tip-desc="${desc}" data-tip-sug="${sug}"
                       style="left:${ann.x_pct}%;top:${ann.y_pct}%;width:${ann.width_pct}%;height:${ann.height_pct}%;z-index:${zIndex}">
                    <span class="ann-label">${num}</span>
                  </div>`;
        }).join('');
      }

      const label = frameNames[frameIdx]
        ? `<span class="frame-label">${frameIdx + 1}. ${esc(frameNames[frameIdx])}</span>`
        : `<span class="frame-label">${frameIdx + 1}.</span>`;

      return `<div class="annotation-container">
                ${label}
                <div class="annotation-image-wrapper">
                  <img src="data:image/jpeg;base64,${img}" alt="Frame ${frameIdx + 1}">
                  ${boxesHtml}
                </div>
              </div>`;
    }).join('');

    return images.length > 1 ? `<div class="flow-strip">${framesHtml}</div>` : framesHtml;
  }

  function buildIssuesHtml(issues) {
    return issues.map((issue, idx) => `
      <div class="issue" data-issue-index="${idx}">
        <span style="font-size:10px;font-weight:700;color:#18a0fb;margin-right:3px;">${idx + 1}</span>
        <span class="issue-severity severity-${esc(issue.severity)}">${esc(issue.severity)}</span>
        <strong>${esc(issue.area)}:</strong> ${esc(issue.description)}
        <br><em style="color:#666">&rarr; ${esc(issue.suggestion)}</em>
      </div>
    `).join('');
  }

  function buildPositivesHtml(positives) {
    if (positives.length === 0) return '';
    return `<div class="positives-section"><div class="positives-heading">What's working well</div>${positives.map(p => `<div class="positive">${esc(p)}</div>`).join('')}</div>`;
  }

  // Wire hover/click interactions between issues and annotation boxes
  function wireIssueAnnotationInteractions(card, annotationScope) {
    card.querySelectorAll('.issue[data-issue-index]').forEach(issueEl => {
      const idx = issueEl.dataset.issueIndex;
      issueEl.addEventListener('mouseenter', () => {
        annotationScope.querySelectorAll(`.annotation-box[data-issue-index="${idx}"]`)
            .forEach(b => { b.classList.add('highlight'); });
      });
      issueEl.addEventListener('mouseleave', () => {
        annotationScope.querySelectorAll('.annotation-box.highlight')
            .forEach(b => { b.classList.remove('highlight'); });
      });
      issueEl.addEventListener('click', () => {
        const boxes = annotationScope.querySelectorAll(`.annotation-box[data-issue-index="${idx}"]`);
        if (boxes.length > 0) {
          const target = boxes[0];
          const strip = target.closest('.flow-strip');
          if (strip) {
            const annContainer = target.closest('.annotation-container');
            if (annContainer) {
              strip.scrollTo({ left: annContainer.offsetLeft - 8, behavior: 'smooth' });
            }
          }
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
          target.classList.add('flash');
          target.addEventListener('animationend', () => {
            target.classList.remove('flash');
          }, { once: true });
        }
      });
    });

    annotationScope.querySelectorAll('.annotation-box[data-issue-index]').forEach(boxEl => {
      const idx = boxEl.dataset.issueIndex;
      boxEl.addEventListener('mouseenter', () => {
        card.querySelectorAll(`.issue[data-issue-index="${idx}"]`)
            .forEach(i => { i.classList.add('highlight'); });
      });
      boxEl.addEventListener('mouseleave', () => {
        card.querySelectorAll('.issue.highlight')
            .forEach(i => { i.classList.remove('highlight'); });
      });
    });
  }

  // Render a single feedback card into the container (with images and annotations)
  function renderSingleFeedbackCard(container, fb) {
    const card = document.createElement('div');
    card.className = 'feedback-card';

    const images = getCurrentImages();
    const frameNames = getCurrentFrameNames();
    const annotations = fb.annotations && fb.annotations.length > 0 ? fb.annotations : null;
    const annotationHtml = images.length > 0 ? buildFrameHtml(images, frameNames, annotations, fb.issues) : '';

    card.innerHTML = `
      ${annotationHtml}
      <div class="impression">"${esc(fb.overall_impression)}"</div>
      ${buildIssuesHtml(fb.issues)}
      ${buildPositivesHtml(fb.positives)}
    `;

    // Wire hover interactions — in 2-col mode, annotations are in the shared images column
    const annotationScope = twoColMode
      ? document.querySelector('.images-column') || card
      : card;
    wireIssueAnnotationInteractions(card, annotationScope);
    wireAnnotationTooltips(card);

    container.appendChild(card);
  }

  function switchTab(activeTab) {
    // Deactivate all tabs and panels
    document.querySelectorAll('.persona-tab').forEach(t => { t.classList.remove('active'); });
    document.querySelectorAll('.tab-panel').forEach(p => { p.classList.remove('active'); });
    // Activate selected
    activeTab.classList.add('active');
    const panel = document.getElementById(activeTab.dataset.panelId);
    if (panel) panel.classList.add('active');

    // In 2-col mode, update annotation boxes on shared images for the active persona
    if (twoColMode) {
      const panelId = activeTab.dataset.panelId;
      const match = panelId?.match(/^panel-(\d+)$/);
      if (match) {
        const idx = parseInt(match[1], 10);
        if (allFeedbackStore[idx]) {
          updateImageAnnotations(allFeedbackStore[idx]);
        }
      }
    }
  }

  // Update annotation boxes on the shared images column for a given persona's feedback
  function updateImageAnnotations(fb, imagesCol) {
    if (!imagesCol) imagesCol = document.querySelector('.images-column');
    if (!imagesCol) return;

    // Remove existing annotation boxes
    imagesCol.querySelectorAll('.annotation-box').forEach(b => { b.remove(); });

    if (!fb.annotations || fb.annotations.length === 0) return;

    const wrappers = imagesCol.querySelectorAll('.annotation-image-wrapper');

    // Sort by area (largest first) so smaller boxes render on top
    const sorted = fb.annotations.map((ann, i) => ({ ann, i }));
    sorted.sort((a, b) => (b.ann.width_pct * b.ann.height_pct) - (a.ann.width_pct * a.ann.height_pct));

    sorted.forEach((entry, renderIdx) => {
      const { ann } = entry;
      const frameIdx = ann.frame_index || 0;
      const wrapper = wrappers[frameIdx];
      if (!wrapper) return;

      const issue = fb.issues[ann.issue_index];
      const severity = issue ? issue.severity : 'medium';
      const area = issue ? esc(issue.area) : esc(ann.label);
      const desc = issue ? esc(issue.description) : '';
      const num = ann.issue_index + 1;
      const sug = issue ? esc(issue.suggestion) : '';
      const zIndex = renderIdx + 1;

      const box = document.createElement('div');
      box.className = `annotation-box severity-${severity}`;
      box.dataset.issueIndex = String(ann.issue_index);
      box.dataset.tipNum = String(num);
      box.dataset.tipSev = severity;
      box.dataset.tipArea = area;
      box.dataset.tipDesc = desc;
      box.dataset.tipSug = sug;
      box.style.cssText = `left:${ann.x_pct}%;top:${ann.y_pct}%;width:${ann.width_pct}%;height:${ann.height_pct}%;z-index:${zIndex}`;
      box.innerHTML = `<span class="ann-label">${num}</span>`;

      wrapper.appendChild(box);
    });

    wireAnnotationTooltips(imagesCol);

    // Wire box hover → highlight corresponding issue in the active panel
    imagesCol.querySelectorAll('.annotation-box[data-issue-index]').forEach(boxEl => {
      const idx = boxEl.dataset.issueIndex;
      boxEl.addEventListener('mouseenter', () => {
        const activePanel = document.querySelector('.tab-panel.active');
        if (activePanel) {
          activePanel.querySelectorAll(`.issue[data-issue-index="${idx}"]`)
            .forEach(i => { i.classList.add('highlight'); });
        }
      });
      boxEl.addEventListener('mouseleave', () => {
        const activePanel = document.querySelector('.tab-panel.active');
        if (activePanel) {
          activePanel.querySelectorAll('.issue.highlight')
            .forEach(i => { i.classList.remove('highlight'); });
        }
      });
    });
  }

  // Build tabbed UI with tab bar and panels for a feedback list
  function buildTabbedFeedback(container, feedbackList, renderCard) {
    const tabBar = document.createElement('div');
    tabBar.className = 'persona-tabs';
    container.appendChild(tabBar);

    const panelsContainer = document.createElement('div');
    container.appendChild(panelsContainer);

    feedbackList.forEach((fb, idx) => {
      const panelId = `panel-${idx}`;
      const tab = document.createElement('button');
      tab.className = `persona-tab${idx === 0 ? ' active' : ''}`;
      tab.dataset.panelId = panelId;
      tab.innerHTML = `${esc(fb.persona_label)} <span class="tab-score">${fb.score}/10</span>`;
      tab.onclick = () => switchTab(tab);
      tabBar.appendChild(tab);

      const panel = document.createElement('div');
      panel.className = `tab-panel${idx === 0 ? ' active' : ''}`;
      panel.id = panelId;
      renderCard(panel, fb);
      panelsContainer.appendChild(panel);
    });
  }

  // Render feedback cards (called on layout toggle to re-render from allFeedbackStore)
  function renderFeedback(feedbackList) {
    const container = document.getElementById('feedbackCards');
    container.innerHTML = '';

    if (twoColMode && feedbackList.length > 0) {
      // 2-col: shared images on left, tabbed feedback on right
      const wrapper = document.createElement('div');
      wrapper.className = 'results-2col';

      const imagesCol = document.createElement('div');
      imagesCol.className = 'images-column';

      const feedbackCol = document.createElement('div');
      feedbackCol.className = 'feedback-column';

      // Build shared images (no annotations — added per active tab)
      const images = getCurrentImages();
      const frameNames = getCurrentFrameNames();
      imagesCol.innerHTML = buildFrameHtml(images, frameNames, null, null);

      // Overlay the first persona's annotations
      updateImageAnnotations(feedbackList[0], imagesCol);

      // Build tabs in right column — cards without images (they're in the shared panel)
      buildTabbedFeedback(feedbackCol, feedbackList, (panel, fb) => {
        const card = document.createElement('div');
        card.className = 'feedback-card';
        card.innerHTML = `
          <div class="impression">"${esc(fb.overall_impression)}"</div>
          ${buildIssuesHtml(fb.issues)}
          ${buildPositivesHtml(fb.positives)}
        `;
        wireIssueAnnotationInteractions(card, imagesCol);
        panel.appendChild(card);
      });

      wrapper.appendChild(imagesCol);
      wrapper.appendChild(feedbackCol);
      container.appendChild(wrapper);
    } else {
      // 1-col: tabbed layout with images per card
      buildTabbedFeedback(container, feedbackList, renderSingleFeedbackCard);
    }
  }

  function wireAnnotationTooltips(container) {
    const tooltip = document.getElementById('annTooltip');
    container.querySelectorAll('.annotation-box[data-tip-num]').forEach(box => {
      box.addEventListener('mouseenter', () => {
        const sevColors = { high: '#e53e3e', medium: '#d69e2e', low: '#38a169' };
        const sev = box.dataset.tipSev;
        const color = sevColors[sev] || '#888';
        let html = `<span style="display:inline-block;background:${color};color:#fff;font-size:10px;font-weight:700;padding:1px 6px;border-radius:3px;margin-right:6px;text-transform:uppercase">${esc(sev)}</span>`
          + `<strong style="color:#fff;font-size:12px">#${esc(box.dataset.tipNum)} ${esc(box.dataset.tipArea)}</strong>`
          + `<div style="margin-top:4px;color:#ccc">${esc(box.dataset.tipDesc)}</div>`;
        if (box.dataset.tipSug) {
          html += `<div style="margin-top:4px;color:#7ecbff;font-style:italic">\u2192 ${esc(box.dataset.tipSug)}</div>`;
        }
        tooltip.innerHTML = html;
        tooltip.classList.add('visible');
        positionTooltip(box);
      });
      box.addEventListener('mousemove', () => positionTooltip(box));
      box.addEventListener('mouseleave', () => tooltip.classList.remove('visible'));
    });
  }

  function positionTooltip(box) {
    const tooltip = document.getElementById('annTooltip');
    const rect = box.getBoundingClientRect();
    // Position above the annotation box, aligned to its left edge
    let left = rect.left;
    let top = rect.top - tooltip.offsetHeight - 6;
    // If it would go above the viewport, show below instead
    if (top < 4) {
      top = rect.bottom + 6;
    }
    // Keep within horizontal bounds
    const maxLeft = window.innerWidth - tooltip.offsetWidth - 8;
    if (left > maxLeft) left = maxLeft;
    if (left < 4) left = 4;
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
  }

  // Connect button
  document.getElementById('btnConnect').onclick = () => {
    const url = document.getElementById('apiUrl').value.trim();
    if (url) checkAuthRequired(url);
  };

  // Change Backend buttons
  document.getElementById('btnChangeBackend').onclick = () => {
    showState('state-connect');
  };

  document.getElementById('btnChangeBackendEmpty').onclick = () => {
    showState('state-connect');
  };

  // New Feedback / Retry buttons
  document.getElementById('btnNewFeedback').onclick = () => {
    showState('state-ready');
  };
  document.getElementById('btnRetry').onclick = () => {
    if (currentImage || currentFrames) {
      // Re-build progress UI and send directly
      const personas = getSelectedPersonas();
      if (personas.length > 0) {
        buildProgressUI();
        showState('state-results');
        document.getElementById('btnNewFeedback').style.display = 'none';
      }
      sendFeedbackRequest();
    } else {
      const personas = getSelectedPersonas();
      if (personas.length > 0) {
        buildProgressUI();
        showState('state-results');
        document.getElementById('btnNewFeedback').style.display = 'none';
      }
      parent.postMessage({ pluginMessage: { type: 'export-selection' } }, '*');
    }
  };

  // Size selector buttons
  document.querySelectorAll('.size-btn').forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll('.size-btn').forEach(b => { b.classList.remove('active'); });
      btn.classList.add('active');
      const w = parseInt(btn.dataset.w, 10);
      const h = parseInt(btn.dataset.h, 10);
      parent.postMessage({ pluginMessage: { type: 'resize', width: w, height: h } }, '*');
    };
  });

  // Layout toggle (1-col / 2-col)
  document.getElementById('layoutToggle').onclick = () => {
    twoColMode = !twoColMode;
    const btn = document.getElementById('layoutToggle');
    btn.classList.toggle('active', twoColMode);
    btn.textContent = twoColMode ? '1-col' : '2-col';
    // Re-layout if results are visible
    const resultsEl = document.getElementById('state-results');
    if (resultsEl.style.display !== 'none') {
      applyLayout();
    }
  };

  function applyLayout() {
    if (allFeedbackStore.length > 0) {
      renderFeedback(allFeedbackStore);
    }
  }
</script>

<div class="brand-footer">
    <span>Powered by</span>
    <svg viewBox="0 0 572 110" fill="none" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Blend360 logo">
        <path d="M0 90.2811V25.1138H48.9904C64.5239 25.1138 70.3146 32.0074 70.3146 41.3826C70.3146 48.552 66.2703 53.883 59.2848 56.4566C67.4652 58.3868 74.0831 62.9825 74.0831 72.5416C74.0831 83.2956 67.1895 90.2811 53.1265 90.2811H0ZM12.3165 81.0897H49.2661C56.895 81.0897 61.307 78.1484 61.307 71.1629C61.307 63.6259 55.4244 61.42 49.2661 61.42H12.3165V81.0897ZM12.3165 53.5154H45.5896C52.2074 53.5154 58.0899 51.2175 58.0899 43.7724C58.0899 37.1546 53.6781 34.3052 45.5896 34.3052H12.3165V53.5154Z" fill="#FFFFFF"/>
        <path d="M79.532 90.2811V16.7496H91.6647V90.2811H79.532Z" fill="#FFFFFF"/>
        <path d="M136.308 92.1194C112.778 92.1194 98.4392 81.3654 98.4392 63.1664C98.4392 44.9673 113.054 34.1214 135.665 34.1214C158.459 34.1214 172.338 45.335 172.338 67.5783H111.583C113.421 77.2293 122.245 82.3765 136.676 82.3765C148.533 82.3765 156.529 78.6999 158.919 72.4497H171.511C168.202 84.7663 156.161 92.1194 136.308 92.1194ZM111.767 58.1111H159.195C156.989 48.1843 148.9 43.7724 135.756 43.7724C122.521 43.7724 113.973 48.3681 111.767 58.1111Z" fill="#FFFFFF"/>
        <path d="M178.454 90.2811V35.9597H191.322V47.7247C198.308 38.9929 209.062 34.1214 223.033 34.1214C240.497 34.1214 251.159 41.1988 251.159 62.6149V90.2811H238.291V66.9349C238.291 50.9417 232.041 44.8754 217.242 44.8754C201.893 44.8754 191.322 53.2396 191.322 67.3944V90.2811H178.454Z" fill="#FFFFFF"/>
        <path d="M320.105 90.2811V78.8838C314.499 87.248 304.02 92.2113 290.969 92.2113C270.747 92.2113 257.696 80.814 257.696 63.2583C257.696 45.7026 270.747 34.2133 290.969 34.2133C304.02 34.2133 314.499 39.1767 320.105 47.6328V16.7496H332.146V90.2811H320.105ZM271.023 63.2583C271.023 74.288 280.123 81.4574 294.829 81.4574C310.546 81.4574 320.105 74.288 320.105 63.2583C320.105 52.1366 310.546 44.9673 294.829 44.9673C280.123 44.9673 271.023 52.1366 271.023 63.2583Z" fill="#FFFFFF"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M376.722 38.4239L377.455 70.7398V70.7947C377.455 73.5757 378.919 76.7858 382.791 80.268C386.662 83.7488 392.536 87.1066 400.209 90.0262C415.52 95.8526 436.999 99.5597 460.964 99.5597C484.929 99.5597 506.408 95.8564 521.719 90.032C529.392 87.1134 535.265 83.7562 539.136 80.2751C543.007 76.793 544.473 73.5808 544.473 70.7947C544.473 68.0086 543.007 64.7965 539.136 61.3144C538.757 60.9735 538.359 60.6339 537.941 60.2957C534.004 62.7126 529.452 64.878 524.446 66.7821C507.773 73.1247 485.068 76.9456 460.231 76.9456C443.555 76.9456 431.367 76.1544 419.479 73.4768C407.649 70.8124 396.354 66.3341 381.4 59.2511C380.59 58.9095 379.133 58.0418 378.581 56.0815C377.992 53.9869 378.98 52.4256 379.221 52.0646C379.568 51.5466 379.935 51.2183 380.074 51.0978C380.252 50.9425 380.407 50.8302 380.5 50.766C380.798 50.559 381.071 50.4202 381.139 50.3855L381.146 50.3822C381.355 50.276 381.58 50.1756 381.755 50.0992C382.141 49.9314 382.673 49.7135 383.318 49.4592C384.62 48.9453 386.509 48.2332 388.871 47.3908C393.598 45.7053 400.277 43.4777 408.032 41.255C423.443 36.8376 443.499 32.3215 460.964 32.3215C485.8 32.3215 508.506 36.1424 525.179 42.485C529.828 44.2536 534.087 46.2478 537.825 48.4595C538.022 48.2909 538.215 48.1219 538.403 47.9527C542.275 44.4706 543.74 41.2584 543.74 38.4723C543.74 35.6862 542.275 32.4741 538.403 28.992C534.533 25.5108 528.659 22.1537 520.987 19.235C505.676 13.4107 484.197 9.70731 460.231 9.70731C436.266 9.70731 414.787 13.4107 399.476 19.235C391.804 22.1537 385.93 25.5108 382.059 28.992C378.21 32.4539 376.739 35.6491 376.722 38.4239ZM545.849 54.2897C550.406 49.8895 553.46 44.5611 553.46 38.4723C553.46 31.9731 549.98 26.3403 544.908 21.7778C539.834 17.2143 532.766 13.3274 524.446 10.1626C507.773 3.82001 485.068 -0.000915527 460.231 -0.000915527C435.395 -0.000915527 412.689 3.82001 396.016 10.1626C387.697 13.3274 380.629 17.2143 375.555 21.7778C370.483 26.3403 367.002 31.9731 367.002 38.4723V38.5273L367.735 70.8539C367.756 77.3252 371.232 82.9358 376.288 87.4828C381.361 92.0451 388.429 95.9325 396.748 99.0983C413.421 105.443 436.126 109.268 460.964 109.268C485.8 109.268 508.506 105.447 525.179 99.1045C533.498 95.9396 540.566 92.0527 545.64 87.4893C550.712 82.9268 554.193 77.2939 554.193 70.7947C554.193 64.3852 550.808 58.8183 545.849 54.2897ZM528.462 54.4529C526.399 53.4504 524.149 52.4819 521.719 51.5574C506.408 45.7331 484.929 42.0297 460.964 42.0297C444.88 42.0297 425.872 46.2415 410.713 50.5866C405.078 52.2017 400.03 53.8189 395.936 55.2121C405.59 59.4142 413.532 62.1853 421.617 64.0063C432.469 66.4504 443.821 67.2374 460.231 67.2374C484.197 67.2374 505.676 63.534 520.987 57.7096C523.708 56.6745 526.203 55.5843 528.462 54.4529Z" fill="#FFFFFF"/>
        <path d="M552.197 12.7749V1.42855H547.944V-0.000915527H558.058V1.42855H553.805V12.7749H552.197Z" fill="#FFFFFF"/>
        <path d="M558.984 12.7749V-0.000915527H561.182L565.184 10.6128H565.22L569.222 -0.000915527H571.42V12.7749H569.812V2.26836H569.776L565.917 12.7749H564.487L560.628 2.26836H560.592V12.7749H558.984Z" fill="#FFFFFF"/>
    </svg>
</div>

</body>
</html>
